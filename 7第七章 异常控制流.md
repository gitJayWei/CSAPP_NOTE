## 7. 异常控制流

- 处理器从加电到断电，程序计数器的 地址序列 $a_0,a_1,...a_{n-1}$ 对应指令的执行顺序 (每个 $a_k$ 就是指令 $I_k$ 的地址)，每次从 $a_k$ 到 $a_{k+1}$ 的转移称为控制转移，这样的控制转移序列就是处理器的**控制流**；
  - 控制流并不总是“平滑的”，程序内部的跳转，调用和返回会导致控制流突变；系统状态变化(硬件定时器信号、网络数据到达、磁盘数据就绪)也会导致控制流突变；
  - 由系统状态变化导致的控制流突变就是**异常控制流(ECF)**；

- ECF是应用与操作系统、硬件交互的核心逻辑，存在于系统的各个层次；

### 7.0 异常

> - 处理器状态用不同的位和硬件标识进行编码，处理器状态的变化称为**事件**；
>   - 事件可能与当前指令相关，比如试图除以零；
>   - 事件也可能与当前指令无关，比如一个IO请求完成；

- 异常是硬件层的ECF（？，系统调用是应用与OS间的异常），用于**响应事件发生**，其实现由硬件和软件协同完成；

#### 7.0.0. 异常处理

- 系统为每种异常都分配了一个唯一的异常号(一部分由CPU分配，一部分由OS分配)；
- 系统启动时，OS初始化一张异常表，该表的表目 $k$ 包含异常 $k$ 的处理程序的地址；
- 一个事件发生，CPU或OS会确定对应的异常号，随后触发异常；
  - 根据异常号和异常表基址寄存器找到对应的异常表表目，拿到对应异常处理程序的基址，从而转到相应的处理程序；

- 异常类似于过程调用，但是有不同：
  - 过程调用中，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，异常的类型会决定返回到当前指令还是下一条指令；
  - 处理器也会把一些额外的处理器状态压入栈，处理程序返回后，重新开始执行被中断的程序会需要这些状态；
  - 如果控制从用户程序转到内核，所有这些项目都被压到内核栈中，而不是用户栈；
  - 异常处理程序运行在内核模式下，也就是说它们可以访问所有的系统资源；
- 